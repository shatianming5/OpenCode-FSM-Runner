from __future__ import annotations

import os
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from .paths import resolve_workdir
from .pipeline_spec import PipelineSpec
from .security import cmd_allowed, looks_interactive, safe_env
from .subprocess_utils import read_text_if_exists, run_cmd_capture, write_cmd_artifacts, write_json, write_text
from .types import CmdResult, StageResult


@dataclass(frozen=True)
class BootstrapSpec:
    """中文说明：
    - 含义：`.aider_fsm/bootstrap.yml` 的解析后结构（v1）。
    - 内容：描述在 pipeline 验收前要执行的命令（可为空）以及要应用的 env/workdir/timeout/retries。
    - 可简略：否（bootstrap 是复现/同机调用的重要能力；结构化对象便于测试与演进）。
    """
    # 作用：中文说明：
    # 能否简略：否
    # 原因：规模≈24 行；引用次数≈5（静态近似，可能包含注释/字符串）；多点复用或涉及副作用/协议验收，过度简化会增加回归风险或降低可审计性
    # 证据：位置=runner/bootstrap.py:23；类型=class；引用≈5；规模≈24行

    version: int = 1
    cmds: list[str] = field(default_factory=list)
    env: dict[str, str] = field(default_factory=dict)
    workdir: str | None = None
    timeout_seconds: int | None = None
    retries: int = 0


@dataclass(frozen=True)
class BootstrapLoadResult:
    """Structured bootstrap parse output with non-fatal normalization warnings."""
    # 作用：Structured bootstrap parse output with non-fatal normalization warnings.
    # 能否简略：否
    # 原因：规模≈10 行；引用次数≈3（静态近似，可能包含注释/字符串）；多点复用或涉及副作用/协议验收，过度简化会增加回归风险或降低可审计性
    # 证据：位置=runner/bootstrap.py:46；类型=class；引用≈3；规模≈10行

    spec: BootstrapSpec
    raw: str
    warnings: list[str] = field(default_factory=list)


_VAR_BRACE_RE = re.compile(r"\$\{([A-Za-z_][A-Za-z0-9_]*)\}")
_VAR_BARE_RE = re.compile(r"\$([A-Za-z_][A-Za-z0-9_]*)")
_DOLLAR_PLACEHOLDER = "\x00DOLLAR\x00"


def _normalize_bootstrap_applied_env_paths(repo: Path, applied_env: dict[str, str]) -> dict[str, str]:
    """Normalize common path-like bootstrap env values to be robust across workdirs.

    Why this exists:
    - Many scaffolded `bootstrap.yml` files set values like:
      - `PATH: ".aider_fsm/venv/bin:$PATH"`
      - `AIDER_FSM_PYTHON: ".aider_fsm/venv/bin/python"`
    - Some stages (notably `runner.hints_exec`) may execute commands from an isolated
      workdir under `$AIDER_FSM_ARTIFACTS_DIR`, where relative PATH segments would
      no longer resolve to the repo's venv.
    """
    # 作用：Normalize common path-like bootstrap env values to be robust across workdirs.
    # 能否简略：否
    # 原因：涉及跨 workdir 的稳定性修复（真实运行中会导致 command not found）；规模≈40 行；引用次数≈1（静态近似，可能包含注释/字符串）
    # 证据：位置=runner/bootstrap.py:144；类型=function；引用≈1；规模≈40行
    root = Path(repo).resolve()
    out = dict(applied_env or {})

    py = str(out.get("AIDER_FSM_PYTHON") or "").strip()
    if py:
        try:
            p = Path(py)
            if not p.is_absolute():
                # Do not use `.resolve()` here: venv interpreters are often symlinks to the
                # base interpreter, and resolving the symlink breaks venv isolation.
                out["AIDER_FSM_PYTHON"] = str((root / p).absolute())
        except Exception:
            pass

    raw_path = str(out.get("PATH") or "").strip()
    if raw_path:
        parts = raw_path.split(os.pathsep)
        new_parts: list[str] = []
        changed = False
        for item in parts:
            seg = str(item or "")
            if seg == "":
                # Preserve empty segments (meaning: current directory).
                new_parts.append("")
                continue
            if "$" in seg:
                new_parts.append(seg)
                continue
            try:
                p2 = Path(seg)
            except Exception:
                new_parts.append(seg)
                continue
            if p2.is_absolute():
                new_parts.append(seg)
                continue
            new_parts.append(str((root / p2).absolute()))
            changed = True
        if changed:
            out["PATH"] = os.pathsep.join(new_parts)

    return out


def _coerce_cmds(raw: Any, *, field_name: str, warnings: list[str]) -> list[str]:
    # 作用：内部符号：_coerce_cmds
    # 能否简略：否
    # 原因：规模≈49 行；引用次数≈2（静态近似，可能包含注释/字符串）；多点复用或涉及副作用/协议验收，过度简化会增加回归风险或降低可审计性
    # 证据：位置=runner/bootstrap.py:153；类型=function；引用≈2；规模≈49行
    out: list[str] = []

    if raw is None:
        return out

    if isinstance(raw, str):
        s = raw.strip()
        if s:
            warnings.append(f"bootstrap.{field_name}_coerced_from_string")
            return [s]
        return out

    if isinstance(raw, dict):
        cmd = raw.get("cmd")
        if cmd is None:
            cmd = raw.get("run")
        if cmd is None:
            cmd = raw.get("command")
        if isinstance(cmd, str) and cmd.strip():
            warnings.append(f"bootstrap.{field_name}_mapping_coerced_to_single_cmd")
            return [cmd.strip()]
        raise ValueError(
            f"bootstrap.{field_name} mapping must contain one of keys: cmd, run, command "
            "(with non-empty string value)"
        )

    if not isinstance(raw, list):
        raise ValueError(f"bootstrap.{field_name} must be a list of non-empty strings")

    for i, item in enumerate(raw):
        if isinstance(item, str) and item.strip():
            out.append(item.strip())
            continue
        if isinstance(item, dict):
            cmd = item.get("cmd")
            if cmd is None:
                cmd = item.get("run")
            if cmd is None:
                cmd = item.get("command")
            if isinstance(cmd, str) and cmd.strip():
                out.append(cmd.strip())
                warnings.append(f"bootstrap.{field_name}[{i}]_mapping_coerced_via_run")
                continue
        raise ValueError(
            f"bootstrap.{field_name}[{i}] must be a non-empty string "
            "or mapping with cmd/run/command"
        )
    return out


def load_bootstrap_spec_with_diagnostics(path: Path) -> BootstrapLoadResult:
    """Load bootstrap.yml and tolerate common scaffold formatting variants.

    This keeps parsing strict enough for safety while handling typical agent outputs
    (e.g. `boot:` wrapper, `steps` alias, mapping-style step items).
    """
    # 作用：Load bootstrap.yml and tolerate common scaffold formatting variants.
    # 能否简略：否
    # 原因：规模≈74 行；引用次数≈7（静态近似，可能包含注释/字符串）；多点复用或涉及副作用/协议验收，过度简化会增加回归风险或降低可审计性
    # 证据：位置=runner/bootstrap.py:228；类型=function；引用≈7；规模≈74行
    try:
        import yaml  # type: ignore
    except Exception as e:  # pragma: no cover
        raise RuntimeError("Missing dependency: PyYAML. Install with `pip install PyYAML`.") from e

    raw = read_text_if_exists(path).strip()
    if not raw:
        raise ValueError(f"bootstrap file is empty: {path}")
    data = yaml.safe_load(raw)
    if not isinstance(data, dict):
        raise ValueError("bootstrap.yml must be a YAML mapping (dict) at the top level")

    warnings: list[str] = []
    obj = dict(data or {})
    boot = obj.get("boot")
    if isinstance(boot, dict):
        top_level_keys = {"cmds", "steps", "env", "workdir", "cwd", "timeout_seconds", "timeout", "retries", "retry"}
        has_top_level_spec = any(k in obj for k in top_level_keys)
        if not has_top_level_spec:
            merged = dict(boot)
            for k, v in obj.items():
                if k == "boot":
                    continue
                merged[k] = v
            obj = merged
            warnings.append("bootstrap.boot_mapping_unwrapped")
        else:
            warnings.append("bootstrap.boot_mapping_ignored_due_to_top_level_fields")

    version = int(obj.get("version") or 1)
    if version != 1:
        raise ValueError(f"unsupported bootstrap version: {version}")

    cmds_src = obj.get("cmds")
    if cmds_src is None and obj.get("steps") is not None:
        cmds_src = obj.get("steps")
        warnings.append("bootstrap.steps_alias_used")
    cmds = _coerce_cmds(cmds_src, field_name="cmds", warnings=warnings)

    env = obj.get("env") or {}
    if env is None:
        env = {}
    if not isinstance(env, dict):
        raise ValueError("bootstrap.env must be a mapping")
    env_out: dict[str, str] = {}
    for k, v in env.items():
        if k is None:
            continue
        ks = str(k).strip()
        if not ks:
            continue
        env_out[ks] = "" if v is None else str(v)

    workdir_raw = obj.get("workdir")
    if workdir_raw is None and obj.get("cwd") is not None:
        workdir_raw = obj.get("cwd")
        warnings.append("bootstrap.cwd_alias_used")
    workdir = str(workdir_raw).strip() if workdir_raw else None

    timeout_raw = obj.get("timeout_seconds")
    if timeout_raw is None and obj.get("timeout") is not None:
        timeout_raw = obj.get("timeout")
        warnings.append("bootstrap.timeout_alias_used")
    timeout_seconds = None
    if timeout_raw is not None:
        s = str(timeout_raw).strip()
        if s:
            try:
                timeout_seconds = int(s)
            except Exception as e:
                raise ValueError("bootstrap.timeout_seconds must be an integer") from e
            if timeout_seconds < 1:
                raise ValueError("bootstrap.timeout_seconds must be >= 1")

    retries_raw = obj.get("retries")
    if retries_raw is None and obj.get("retry") is not None:
        retries_raw = obj.get("retry")
        warnings.append("bootstrap.retry_alias_used")
    retries = None
    if retries_raw is not None:
        s = str(retries_raw).strip()
        if s:
            try:
                retries = int(s)
            except Exception as e:
                raise ValueError("bootstrap.retries must be an integer") from e
            if retries < 0:
                raise ValueError("bootstrap.retries must be >= 0")
    if retries is None:
        retries = 0

    spec = BootstrapSpec(
        version=version,
        cmds=[c.strip() for c in cmds if c.strip()],
        env=env_out,
        workdir=workdir,
        timeout_seconds=timeout_seconds,
        retries=int(retries),
    )
    return BootstrapLoadResult(spec=spec, raw=raw, warnings=warnings)


def load_bootstrap_spec(path: Path) -> tuple[BootstrapSpec, str]:
    """中文说明：
    - 含义：读取并解析 `.aider_fsm/bootstrap.yml`（v1），返回 (BootstrapSpec, raw_text)。
    - 内容：校验 version/cmds/env/workdir 等字段类型；支持 `steps` 作为 `cmds` 别名；返回 raw 用于 artifacts 固化。
    - 可简略：可能（薄封装；但集中校验便于维护与测试）。
    """
    # 作用：中文说明：
    # 能否简略：否
    # 原因：规模≈8 行；引用次数≈5（静态近似，可能包含注释/字符串）；多点复用或涉及副作用/协议验收，过度简化会增加回归风险或降低可审计性
    # 证据：位置=runner/bootstrap.py:304；类型=function；引用≈5；规模≈8行
    loaded = load_bootstrap_spec_with_diagnostics(path)
    return loaded.spec, loaded.raw


def run_bootstrap(
    repo: Path,
    *,
    bootstrap_path: Path,
    pipeline: PipelineSpec | None,
    unattended: str,
    artifacts_dir: Path,
) -> tuple[StageResult, dict[str, str]]:
    """中文说明：
    - 含义：执行 bootstrap.yml，并返回 (bootstrap 阶段结果, 应用后的 env 变量映射)。
    - 内容：记录 bootstrap.yml/raw/env（脱敏）与每条命令的 artifacts；执行命令受同一套安全策略约束；返回的 applied_env 通常用于把 venv PATH 等注入后续 stages。
    - 可简略：否（这是“一键可复现运行”的关键组成）。

    ---

    English (original intent):
    Run bootstrap commands and return (stage_result, applied_env).
    """
    # 作用：中文说明：
    # 能否简略：否
    # 原因：规模≈105 行；引用次数≈10（静态近似，可能包含注释/字符串）；多点复用或涉及副作用/协议验收，过度简化会增加回归风险或降低可审计性
    # 证据：位置=runner/bootstrap.py:326；类型=function；引用≈10；规模≈105行
    artifacts_dir.mkdir(parents=True, exist_ok=True)

    try:
        loaded = load_bootstrap_spec_with_diagnostics(bootstrap_path)
        spec, raw = loaded.spec, loaded.raw
        if loaded.warnings:
            write_json(artifacts_dir / "bootstrap_parse_warnings.json", {"warnings": list(loaded.warnings)})
    except Exception as e:
        res = CmdResult(cmd=f"parse {bootstrap_path}", rc=2, stdout="", stderr=str(e), timed_out=False)
        write_cmd_artifacts(artifacts_dir, "bootstrap_parse", res)
        write_json(artifacts_dir / "bootstrap_summary.json", {"ok": False, "failed_index": 0, "total_results": 1})
        return StageResult(ok=False, results=[res], failed_index=0), {}

    write_text(artifacts_dir / "bootstrap.yml", raw)

    # Seed commonly-used variables for env expansion.
    env_base = dict(os.environ)
    env_base["AIDER_FSM_REPO_ROOT"] = str(repo.resolve())

    env_for_cmds = dict(env_base)
    applied_env: dict[str, str] = {}
    for k, v in (spec.env or {}).items():
        key = str(k or "").strip()
        if not key:
            continue
        s = str(v or "")
        s = s.replace("$$", _DOLLAR_PLACEHOLDER)
        s = _VAR_BRACE_RE.sub(lambda m: str(env_for_cmds.get(m.group(1)) or ""), s)
        s = _VAR_BARE_RE.sub(lambda m: str(env_for_cmds.get(m.group(1)) or ""), s)
        value = s.replace(_DOLLAR_PLACEHOLDER, "$")
        env_for_cmds[key] = value
        applied_env[key] = value

    applied_env = _normalize_bootstrap_applied_env_paths(repo, applied_env)
    env_for_cmds.update(dict(applied_env))
    env_for_cmds = safe_env(env_for_cmds, {}, unattended=unattended)
    env_for_cmds["AIDER_FSM_STAGE"] = "bootstrap"
    env_for_cmds["AIDER_FSM_ARTIFACTS_DIR"] = str(artifacts_dir.resolve())
    env_for_cmds["AIDER_FSM_REPO_ROOT"] = str(repo.resolve())
    redacted: dict[str, str] = {}
    for k, v in (applied_env or {}).items():
        ku = str(k or "").upper()
        if any(x in ku for x in ("KEY", "TOKEN", "SECRET", "PASSWORD", "PASS", "PWD")):
            redacted[str(k)] = "***redacted***"
        else:
            redacted[str(k)] = "" if v is None else str(v)
    write_json(artifacts_dir / "bootstrap_env.json", redacted)

    try:
        workdir = resolve_workdir(repo, spec.workdir)
    except Exception as e:
        res = CmdResult(cmd=f"resolve_workdir {spec.workdir}", rc=2, stdout="", stderr=str(e), timed_out=False)
        write_cmd_artifacts(artifacts_dir, "bootstrap_workdir_error", res)
        write_json(artifacts_dir / "bootstrap_summary.json", {"ok": False, "failed_index": 0, "total_results": 1})
        return StageResult(ok=False, results=[res], failed_index=0), applied_env

    results: list[CmdResult] = []
    failed_index: int | None = None

    # No cmds is valid: env-only bootstrap.
    for cmd_idx, raw_cmd in enumerate(spec.cmds, start=1):
        cmd = raw_cmd.strip()
        if not cmd:
            continue

        if unattended == "strict" and looks_interactive(cmd):
            res = CmdResult(
                cmd=cmd,
                rc=126,
                stdout="",
                stderr="likely_interactive_command_disallowed_in_strict_mode",
                timed_out=False,
            )
            results.append(res)
            failed_index = len(results) - 1
            write_cmd_artifacts(artifacts_dir, f"bootstrap_cmd{cmd_idx:02d}_try01", res)
            break

        allowed, reason = cmd_allowed(cmd, pipeline=pipeline)
        if not allowed:
            res = CmdResult(cmd=cmd, rc=126, stdout="", stderr=reason or "blocked", timed_out=False)
            results.append(res)
            failed_index = len(results) - 1
            write_cmd_artifacts(artifacts_dir, f"bootstrap_cmd{cmd_idx:02d}_try01", res)
            break

        eff_timeout = spec.timeout_seconds
        if pipeline and pipeline.security_max_cmd_seconds:
            eff_timeout = (
                int(pipeline.security_max_cmd_seconds)
                if eff_timeout is None
                else min(int(eff_timeout), int(pipeline.security_max_cmd_seconds))
            )

        for attempt in range(1, int(spec.retries) + 2):
            res = run_cmd_capture(cmd, workdir, timeout_seconds=eff_timeout, env=env_for_cmds, interactive=False)
            results.append(res)
            write_cmd_artifacts(artifacts_dir, f"bootstrap_cmd{cmd_idx:02d}_try{attempt:02d}", res)
            if res.rc == 0:
                break

        if results and results[-1].rc != 0:
            failed_index = len(results) - 1
            break

    ok = failed_index is None
    write_json(artifacts_dir / "bootstrap_summary.json", {"ok": ok, "failed_index": failed_index, "total_results": len(results)})

    return StageResult(ok=ok, results=results, failed_index=failed_index), applied_env
